### [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water-ii/)
> 使用BFS+PriorityQueue,其思路大致如下:
> 因为要用元素围城"墙"来保存水,那么大概要从四周开始围起,而且由于每个元素表示的墙的高度参差不齐,所以实际可以
> 围住的水的"面积" = 其四周最小墙的高度 - 当前元素的高度(这里计算总水量的方式是遍历每一个元素,然后累加每个元素可以保存的水量),
> 因为每个元素所表示的高度是已知的,而且是固定的.问题在于如何知道每个元素四周组成的墙的高度中的最小值,
> 然后用这个最小值减去该元素表示的实际高度,就是该元素所乘的水量.当然,如果四周墙的高度的最小值小于该元素表示的实际高度,
> 那么该元素所乘的水量为0.

> 具体的步骤:
> 将四周的元素按其表示的高度压入最小堆优先队列中,
> 每次从最小堆中取出一个元素,并不计算该元素的储水量,而是计算其四周元素的储水量.
> 这条原则在一开始是成立的,因为开始压入队列中的元素都是矩阵四周的元素,由于他们处于边缘,没有墙可以围住他们,
> 所以其储水量都为0;这条原则在对非四周的元素也是成立的,因为随着边缘元素的"拓展",内部的元素会被搜索到并且计算他们的储水量,
> 并且在计算完储水量之后也被加入最小堆中,按其可以围成墙的最大高度排序,于是改元素也从内部元素变成了外部元素,
> 成了组成"墙"的元素了.

> 需要注意的点:
> 因为是从最小堆中取元素拓展周围的元素,所以每次取出来的元素均为当前堆中的最小元素,同时也是当前整个状态的组成墙的
> 高度最小的元素,所以该元素在拓展其周围元素计算周围某一个元素的储水量的时候,保证这个元素四周围城墙的最小的高度就是
> 他保存的高度,不会出错.

> 从四周的元素向内部拓展的过程中,每个元素也由"内部元素"变成了围墙用的"外部元素"(最外层的元素一开始就是"外部元素"),
> 有这样一个转换的过程,在这个转换的过程中,计算其可以盛水的"面积",一旦计算完成后,这个元素便没有"储水"意义了, 只有
> "围墙"的作用, 既然要"围墙"为更里面的元素盛水用,那么就要确定其高度,这个高度应该是他自身的高度或者由其拓展过来的
> 元素的高度中的最大值,也就是说这个元素应该继承其拓展过来的元素的最高高度(或者是其自身的高度,如果其自身的高度更大).

> 经常提到个一个词"拓展",就是搜索的方向,本题中就是上下左右,任意一个放下均可.


> BFS VS DFS

| BFS | DFS |
| :-----: | :-----: |
| 求解全局最优解 | 求解是否存在解 |

> 具体如何应用取决于Scenario.