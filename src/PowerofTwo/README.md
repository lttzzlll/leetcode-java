### [Power of Two](https://leetcode.com/problems/power-of-two/description/)

这道题考察的是啥呢?

1. 使用HashSet预存储这些固定的值, 数据量大的情况下应该是最快的.

代码:

```Java
class Solution {
    public boolean isPowerOfTwo(int n) {
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; (int) Math.pow(2, i) < Integer.MAX_VALUE; i++) {
            set.add((int) Math.pow(2, i));
        }
        return set.contains(n);
    }
}
```

使用位运算.

```Java
class Solution {
    public boolean isPowerOfTwo(int n) {
        HashSet<Integer> set = new HashSet<>();
        int i = 1;
        while (i < Integer.MAX_VALUE && i > 0) {
            set.add(i);
            i <<= 1;
        }
        return set.contains(n);
    }
}
```

注意需要解决越界的问题.
```
2 << 31 == -2147483648
```


注意到:
```
2 << 0 = 2 == 10
2 << 1 = 4 == 100
2 << 2 = 8 == 1000
2 << 3 = 16 == 10000
2 << 4 = 32 == 100000
2 << 5 = 64 == 1000000
2 << 6 = 128 == 10000000
2 << 7 = 256 == 100000000
2 << 8 = 512 == 1000000000
2 << 9 = 1024 == 10000000000
2 << 10 = 2048 == 100000000000
2 << 11 = 4096 == 1000000000000
2 << 12 = 8192 == 10000000000000
2 << 13 = 16384 == 100000000000000
2 << 14 = 32768 == 1000000000000000
2 << 15 = 65536 == 10000000000000000
2 << 16 = 131072 == 100000000000000000
2 << 17 = 262144 == 1000000000000000000
2 << 18 = 524288 == 10000000000000000000
2 << 19 = 1048576 == 100000000000000000000
2 << 20 = 2097152 == 1000000000000000000000
2 << 21 = 4194304 == 10000000000000000000000
2 << 22 = 8388608 == 100000000000000000000000
2 << 23 = 16777216 == 1000000000000000000000000
2 << 24 = 33554432 == 10000000000000000000000000
2 << 25 = 67108864 == 100000000000000000000000000
2 << 26 = 134217728 == 1000000000000000000000000000
2 << 27 = 268435456 == 10000000000000000000000000000
2 << 28 = 536870912 == 100000000000000000000000000000
2 << 29 = 1073741824 == 1000000000000000000000000000000
2 << 30 = -2147483648 == 10000000000000000000000000000000
```

所以 2的幂的二进制序列中有且只有一个1,而且位于最左边.

所以可以通过统计n中二进制序列中1个个数来判断n是否是2的幂.

代码:

```Java
class Solution {
    public boolean isPowerOfTwo(int n) {
        int cnt = 0;
        while (n > 0) {
            if ((n & 1) == 1) cnt++;
            n >>= 1;
        }
        return cnt == 1;
    }
}
```

注意: 这里是右移, 而且是逻辑右移.

###### 算术右移，逻辑右移

逻辑右移很简单，只要将二进制数整体右移，左边补0即可

如10101101逻辑右移一位为01010110

算术右移符号位要一起移动，并且在左边补上符号位，也就是如果符号位是1就补1符号位是0就补0

比如：11100算术右移一位为11110（符号位1跟着一起移动并且左边补了1）


